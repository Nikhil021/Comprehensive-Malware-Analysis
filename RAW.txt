Basic Static Analysis:

from CFExplorer
The file sample is PE32 (i3 x86) executable. In teh optional header of teh file it has DLL characteristics which can move, is NX compatible and terminal server aware. This maybe a windows application .exe file.In the resource editor, There is an xml which requesting execution level "asInvoker" meaning it is requesting permssion level as the process that started it. Can be elevated to a higher permission level by selecting "Run as Administrator".

In the imports the file has unknown module szAnsi with unknown imports (nFunctions)

from DIE 
the compiler informtion : MS visual c/c++
language: C/C++
Tool: Visual Studio(2012)

from IDE:
in the imports there are module urlmon using the function "ObtainUserAgentString" which  retrives the USer-Agent HTTP request header string, WININET module for HTTP communication suggesting network communication by the sample. ADVAPI32 for encryption and decryption.


Basic Dynamic Analysis:

fom procmon.exe - in process tree, it runs svchost.exe(PID 5800) and delete the original file contents. Mutex are found in the processdetails of svchost.exe of malware file. registry keys were opened mapped to other location to be used by the replica of "svchost.exe". few files were created in which evxouxu.exe which is the executable persists after boot shown by autoruns.exe. 

from fakenet.exe - Multiple URLs were accessed with domain name "http://adobe-dns-3-adobe.com/*" with ips 192.168.88.128, 192.0.2.123. Majority of URLs have parameter wtie=49444ec67a49 with one exception where additional parameter is given as shown in below figure. Conversations were from 192.168.88.128-192.0.2.123,192.168.88.128-192.168.88.128 for each URL. with destination port always 80 and source port varies as 49721,49728,49739,49749,49759,49773 till 50709. The ip 192.168.88.128 is used by svchost.exe (system executable) to establish communication for windows requests, the malicious svchost executable diverts the Ip to access the URLs


Advanced static and Dynamic Analysis:
Function sub_4023A3:
In this function it is retriving  GetAdapterInfo, GetComputerNameA which are network adapter info, computer details. Computer details are stored in a buffer which is XOR'ed with the adapter information. The encoding process loops across the maximum 8-byte length of the data to be encoded, suggesting that the encoding of a limited portion of data(possibly the MAC address of netowr adapter).

Function sub_402E56:
This function acts as a wrapper around sub_402DF2, taking two arguments(&hem,&unk_403200) and then calling sub_402DF2 with the second argument. It sets the first argument (a1) to the result of sub_402DF2(a2). It is used to initiate the encoding/decoding process carried out by sub_402DF2, and then it stores the result in the memory location pointed to by a1.
Arguments:
_DWORD *a1(&hem): Pointer to a memory location where the result of the encoding/decoding operation will be stored.
int a2(&unk_403200): The second argument, which is passed directly to sub_402DF2 for processing.

Function sub_402DF2:
This is the core function for encoding or decoding data. It is to perform an XOR-based transformation on an input string or data block, potentially for obfuscation or preparation for data transmission.  It initializes two variables, v1 and v2, where v1 is the first byte of the input (*a1), and v2 is the XOR of the first and second bytes of the input. This suggests that v2 determines the length of the operation or the size of the data to be processed.
It allocates memory for the result (result) using sub_401B33, with the size being v2 + 1, likely accounting for the data plus a null terminator.
It performs a loop where for each byte in the input (starting from the third byte, a1[i + 2]), it XORs it with v1 and stores it in the allocated memory. This loop indicates the bulk of the encoding/decoding process. A null terminator to the end of the processed data (*(_BYTE *)(result + v2) = 0).
Arguments:
char *a1: Pointer to the input data that will have XOR-based transformation.

Function wsprintfA:
The wsprintfA function is a Windows API function that writes formatted data to a specified string. This function writes into the buffer byte_404240 a formatted string that is constructed from the format specified by *v7(contents of xor'ed &unk_403200 in function sub_402E56) , with v5(pointer to XOR'ed data) and v6(pointer to first element of XOR'ed data) being the values inserted into the format string at the respective placeholders.

Function sub_401737:
Here few crytpgraphic API calls are made. 

CryptAcquireContextA: ItAcquires a handle to a cryptographic service provider (CSP). This is typically the first step in cryptographic operations, establishing access to a CSP that will perform cryptographic functions.
Parameters:
&phProv: Address of a variable to receive the handle to the CSP.
NULL: Use the default key container.
NULL: Use the default provider.
0x18u (PROV_RSA_FULL): Specifies the type of provider to acquire. PROV_RSA_FULL supports a full range of cryptographic services, including both public/private key and secret key cryptography.
0xF0000000 (CRYPT_VERIFYCONTEXT): Flag indicating that no key container is created or accessed, suitable for operations that don't require a persistent key container (e.g., temporary key generation).

CryptGenKey
This generates a cryptographic session key or a public/private key pair.
Parameters:
phProv: Handle to the CSP acquired by CryptAcquireContextA.
0x6610u (CALG_AES_256): Specifies the type of key to generate. CALG_AES_256 indicates an AES key of 256 bits, a strong symmetric encryption algorithm.
1u (CRYPT_EXPORTABLE): Indicates that the key being generated can be exported, usually set for keys that need to be used across different sessions or transmitted securely.

CryptExportKey
It exports a cryptographic key from a CSP in a secure manner.
Parameters:
(HCRYPTKEY)phKey: The handle to the key generated by CryptGenKey.
0: Indicates no key exchange is happening, so no public key is provided.
8u (PRIVATEKEYBLOB): Specifies the format for the exported key. PRIVATEKEYBLOB is typically used for private keys, but the usage context or API documentation should be verified as this value seems unconventional for CryptExportKey with AES keys.
0: Reserved, must be zero.
NULL and &pdwDataLen: The first call (with NULL) calculates the size needed to store the key blob, returned in pdwDataLen.
(BYTE*)pbData and &pdwDataLen: The second call actually exports the key into pbData using the size previously determined.

CryptDestroyKey
It destroys the cryptographic key and frees associated resources.
Parameters:
(HCRYPTKEY)phKey: Handle to the key that needs to be destroyed.

CryptReleaseContext
It releases the handle to the CSP, freeing any resources used.
Parameters:
phProv: Handle to the CSP to be released.
0: Reserved, must be zero.

The sequence starts by acquiring a cryptographic context, then generates a key, attempts to export this key, and finally releases the key and cryptographic context resources. This function is intended to convey the result of a series of cryptographic and data manipulation operations, possibly serving as a success indicator and holding a memory address upon success. This function is called by sub_40237A() which is called in the main function.


Function sub_4018D1:
This is a function that creates a new process using a command line string provided by lpCommandLine. It returns the process ID of the newly created process if successful, and 0 otherwise.

Parameters:
dwCreationFlags: Controls the priority class and the creation of the process.
a2: Pointer to a variable to receive the process handle if not NULL.
a3: Pointer to a variable to receive the thread handle if not NULL.
lpCommandLine: The command line string to be executed.

Local Variables:
dwProcessId: Stores the process ID of the created process.
StartupInfo: A STARTUPINFOA structure that specifies the window station, desktop, standard handles, and appearance of the main window for the new process.
ProcessInformation: A PROCESS_INFORMATION structure that receives identification information about the new process.

sub_401424 and sub_40140E Initialization: These functions are called to initialize the StartupInfo and ProcessInformation structures by setting their memory to zero. 
Setting StartupInfo.cb: The size of the STARTUPINFOA structure is set to 0x44, which is necessary for the CreateProcessA function to recognize the structure.
CreateProcessA Call: This is the critical part where a new process is created. CreateProcessA is a Windows API function that starts a new program. It takes several parameters, including:
lpApplicationName: Set to NULL, indicating that the command line will specify the application to be executed.
lpCommandLine: Contains the command to be executed.
lpProcessAttributes and lpThreadAttributes: Set to NULL, indicating the process and thread handle are not inheritable.
bInheritHandles: Set to FALSE, indicating that the new process does not inherit any handles.
dwCreationFlags: Passed through from the function's argument, it controls various aspects of process creation like priority and window behavior.
lpEnvironment: Set to NULL, indicating the new process uses the parent's environment block.
lpCurrentDirectory: Also NULL, so the new process will have the same current directory as the calling process.
lpStartupInfo: Points to the StartupInfo structure filled earlier.
lpProcessInformation: Points to the ProcessInformation structure where information about the newly created process and its primary thread is stored.

If a3 (thread handle) is provided, it's set with the thread handle from ProcessInformation. Otherwise, the handle is closed. The same applies to a2 (process handle). sub_4018D1 demonstrates a method to create a new process in Windows. 


Function sub_401235:
This fucntion allows the malware to mask its actions by associating its operations with legitimate processes, here it is the system executable svchost.exe. Here it has 6 parts Initial Setup and Process Creation, Memory Allocation and Manipulation, Virtual Memory Allocation (ZwAllocateVirtualMemory), Code Injection and Execution, Thread Context Manipulation and Resumption, Cleanup.

Initial Setup and Process Creation
System Directory Retrieval and Path Modification: Initially, the function retrieves the system directory, appends a specified path (obtained via sub_402E56), and frees the allocated memory for the path.
Process Creation (CreateProcessA): It attempts to create a new process in a suspended state (CREATE_SUSPENDED flag) using the path built previously.  The handles to the newly created process and its primary thread are stored in ProcessHandle and ThreadHandle, respectively.

Memory Allocation and Manipulation
Module and Section Handling: The malware retrieves the module handle of the current process (probably itself) and calculates the address of a specific section within the module. This section's size is then used to allocate memory (sub_401B33) for copying data.
Memory Copying (sub_401B7A): Copies data from the current process's module into the newly allocated memory.

Virtual Memory Allocation (ZwAllocateVirtualMemory)
This function allocates virtual memory in the context of the target process. It's essential for creating space in the target's address space to inject the malicious code.
Parameters:
ProcessHandle: Handle to the target process obtained from process creation.
&BaseAddress: Initially null, this parameter is updated to point to the base address of the allocated memory region in the target process. It indicates where the allocated memory starts.
RegionSize: The size of the memory region to allocate. It matches the size of the section copied from the malware's module.
0x3000 (MEM_COMMIT): Allocation type, indicating the memory pages are committed.
0x40 (PAGE_EXECUTE_READWRITE): Memory protection, allowing the allocated pages to be executed, read, and written to. This is crucial for executing injected code.

Code Injection and Execution
Relocation and Writing (ZwWriteVirtualMemory): Adjusts addresses within the copied section (via sub_401395) to match the allocation in the target process and writes the manipulated section into the allocated memory in the target process. This step effectively injects the malicious code.

Thread Context Manipulation and Resumption:
Context Retrieval and Modification (ZwSetContextThread): Adjusts the thread context of the target process's primary thread to execute the injected code. This is done by setting the EAX register to point to the injected code, preparing the thread to execute it upon resumption.
Thread Resumption (ZwResumeThread): Resumes the suspended thread in the target process, causing it to execute the injected code.

Cleanup
Finally, the function closes handles to the target process and thread and returns a value indicating success if the injection and execution steps were successful.


At address 0x402906 - push offset sub_4027E3 
The function sub_4027E3 is given as an argument to sub_401235(sub_4027E3). The function pushed is handling mutex which helps the function sub_401235 to access the target process (resource sharing) for code injection without to ensure mutual exclusion principle in handling resources without any deadlocks between the system and malware.

Function sub_4027E3 uses sub_401F09() for creating mutex without errors in handling the target system resource process


function sub_401000:
This the function where the malware tries to connect to internet with retrieved useragentstring and send requests with different headers where it was accessing php filw with several wtie values indicating that it is reading files from internet at domain "http://adobe-dns-3-adobe.com/" and checking the read data from the urls. malware tried to access several files from that domain. This is the function that decodes the command and control server.

